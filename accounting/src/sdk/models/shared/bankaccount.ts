/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { Decimal as Decimal$ } from "../../types";
import { Metadata, Metadata$ } from "./metadata";
import { SupplementalData, SupplementalData$ } from "./supplementaldata";
import * as z from "zod";

/**
 * The type of transactions and balances on the account.
 *
 * @remarks
 * For Credit accounts, positive balances are liabilities, and positive transactions **reduce** liabilities.
 * For Debit accounts, positive balances are assets, and positive transactions **increase** assets.
 */
export enum BankAccountType {
    Unknown = "Unknown",
    Credit = "Credit",
    Debit = "Debit",
}

/**
 * > **Accessing Bank Accounts through Banking API**
 *
 * @remarks
 * >
 * > This datatype was originally used for accessing bank account data both in accounting integrations and open banking aggregators.
 * >
 * > To view bank account data through the Banking API, please refer to the new datatype [here](https://docs.codat.io/banking-api#/schemas/Account)
 *
 * > View the coverage for bank accounts in the <a className="external" href="https://knowledge.codat.io/supported-features/accounting?view=tab-by-data-type&dataType=bankAccounts" target="_blank">Data coverage explorer</a>.
 *
 * ## Overview
 *
 * A list of bank accounts associated with a company and a specific data connection.
 *
 * Bank accounts data includes:
 * * The name and ID of the account in the accounting platform.
 * * The currency and balance of the account.
 * * The sort code and account number.
 */
export type BankAccount = {
    /**
     * Name of the bank account in the accounting platform.
     */
    accountName?: string | null | undefined;
    /**
     * Account number for the bank account.
     *
     * @remarks
     *
     * Xero integrations
     * Only a UK account number shows for bank accounts with GBP currency and a combined total of sort code and account number that equals 14 digits, For non-GBP accounts, the full bank account number is populated.
     *
     * FreeAgent integrations
     * For Credit accounts, only the last four digits are required. For other types, the field is optional.
     */
    accountNumber?: string | null | undefined;
    /**
     * The type of transactions and balances on the account.
     *
     * @remarks
     * For Credit accounts, positive balances are liabilities, and positive transactions **reduce** liabilities.
     * For Debit accounts, positive balances are assets, and positive transactions **increase** assets.
     */
    accountType?: BankAccountType | undefined;
    /**
     * Total available balance of the bank account as reported by the underlying data source. This may take into account overdrafts or pending transactions for example.
     */
    availableBalance?: Decimal$ | number | null | undefined;
    /**
     * Balance of the bank account.
     */
    balance?: Decimal$ | number | null | undefined;
    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     *
     * @remarks
     *
     * ## Unknown currencies
     *
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction.
     *
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    currency?: string | undefined;
    /**
     * International bank account number of the account. Often used when making or receiving international payments.
     */
    iBan?: string | null | undefined;
    /**
     * Identifier for the account, unique for the company in the accounting platform.
     */
    id?: string | undefined;
    /**
     * The institution of the bank account.
     */
    institution?: string | null | undefined;
    metadata?: Metadata | undefined;
    modifiedDate?: string | undefined;
    /**
     * Code used to identify each nominal account for a business.
     */
    nominalCode?: string | null | undefined;
    /**
     * Pre-arranged overdraft limit of the account.
     *
     * @remarks
     *
     * The value is always positive. For example, an overdraftLimit of `1000` means that the balance of the account can go down to `-1000`.
     */
    overdraftLimit?: Decimal$ | number | null | undefined;
    /**
     * Sort code for the bank account.
     *
     * @remarks
     *
     * Xero integrations
     * The sort code is only displayed when the currency = GBP and the sort code and account number sum to 14 digits. For non-GBP accounts, this field is not populated.
     */
    sortCode?: string | null | undefined;
    sourceModifiedDate?: string | undefined;
    /**
     * Supplemental data is additional data you can include in our standard data types.
     *
     * @remarks
     *
     * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    supplementalData?: SupplementalData | undefined;
};

/** @internal */
export const BankAccountType$ = z.nativeEnum(BankAccountType);

/** @internal */
export namespace BankAccount$ {
    export type Inbound = {
        accountName?: string | null | undefined;
        accountNumber?: string | null | undefined;
        accountType?: BankAccountType | undefined;
        availableBalance?: number | null | undefined;
        balance?: number | null | undefined;
        currency?: string | undefined;
        iBan?: string | null | undefined;
        id?: string | undefined;
        institution?: string | null | undefined;
        metadata?: Metadata$.Inbound | undefined;
        modifiedDate?: string | undefined;
        nominalCode?: string | null | undefined;
        overdraftLimit?: number | null | undefined;
        sortCode?: string | null | undefined;
        sourceModifiedDate?: string | undefined;
        supplementalData?: SupplementalData$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<BankAccount, z.ZodTypeDef, Inbound> = z
        .object({
            accountName: z.nullable(z.string()).optional(),
            accountNumber: z.nullable(z.string()).optional(),
            accountType: BankAccountType$.optional(),
            availableBalance: z.nullable(z.number().transform((v) => new Decimal$(v))).optional(),
            balance: z.nullable(z.number().transform((v) => new Decimal$(v))).optional(),
            currency: z.string().optional(),
            iBan: z.nullable(z.string()).optional(),
            id: z.string().optional(),
            institution: z.nullable(z.string()).optional(),
            metadata: Metadata$.inboundSchema.optional(),
            modifiedDate: z.string().optional(),
            nominalCode: z.nullable(z.string()).optional(),
            overdraftLimit: z.nullable(z.number().transform((v) => new Decimal$(v))).optional(),
            sortCode: z.nullable(z.string()).optional(),
            sourceModifiedDate: z.string().optional(),
            supplementalData: SupplementalData$.inboundSchema.optional(),
        })
        .transform((v) => {
            return {
                ...(v.accountName === undefined ? null : { accountName: v.accountName }),
                ...(v.accountNumber === undefined ? null : { accountNumber: v.accountNumber }),
                ...(v.accountType === undefined ? null : { accountType: v.accountType }),
                ...(v.availableBalance === undefined
                    ? null
                    : { availableBalance: v.availableBalance }),
                ...(v.balance === undefined ? null : { balance: v.balance }),
                ...(v.currency === undefined ? null : { currency: v.currency }),
                ...(v.iBan === undefined ? null : { iBan: v.iBan }),
                ...(v.id === undefined ? null : { id: v.id }),
                ...(v.institution === undefined ? null : { institution: v.institution }),
                ...(v.metadata === undefined ? null : { metadata: v.metadata }),
                ...(v.modifiedDate === undefined ? null : { modifiedDate: v.modifiedDate }),
                ...(v.nominalCode === undefined ? null : { nominalCode: v.nominalCode }),
                ...(v.overdraftLimit === undefined ? null : { overdraftLimit: v.overdraftLimit }),
                ...(v.sortCode === undefined ? null : { sortCode: v.sortCode }),
                ...(v.sourceModifiedDate === undefined
                    ? null
                    : { sourceModifiedDate: v.sourceModifiedDate }),
                ...(v.supplementalData === undefined
                    ? null
                    : { supplementalData: v.supplementalData }),
            };
        });

    export type Outbound = {
        accountName?: string | null | undefined;
        accountNumber?: string | null | undefined;
        accountType?: BankAccountType | undefined;
        availableBalance?: number | null | undefined;
        balance?: number | null | undefined;
        currency?: string | undefined;
        iBan?: string | null | undefined;
        id?: string | undefined;
        institution?: string | null | undefined;
        metadata?: Metadata$.Outbound | undefined;
        modifiedDate?: string | undefined;
        nominalCode?: string | null | undefined;
        overdraftLimit?: number | null | undefined;
        sortCode?: string | null | undefined;
        sourceModifiedDate?: string | undefined;
        supplementalData?: SupplementalData$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, BankAccount> = z
        .object({
            accountName: z.nullable(z.string()).optional(),
            accountNumber: z.nullable(z.string()).optional(),
            accountType: BankAccountType$.optional(),
            availableBalance: z
                .nullable(
                    z
                        .union([z.instanceof(Decimal$), z.number()])
                        .transform((v) => (typeof v === "number" ? v : v.toNumber()))
                )
                .optional(),
            balance: z
                .nullable(
                    z
                        .union([z.instanceof(Decimal$), z.number()])
                        .transform((v) => (typeof v === "number" ? v : v.toNumber()))
                )
                .optional(),
            currency: z.string().optional(),
            iBan: z.nullable(z.string()).optional(),
            id: z.string().optional(),
            institution: z.nullable(z.string()).optional(),
            metadata: Metadata$.outboundSchema.optional(),
            modifiedDate: z.string().optional(),
            nominalCode: z.nullable(z.string()).optional(),
            overdraftLimit: z
                .nullable(
                    z
                        .union([z.instanceof(Decimal$), z.number()])
                        .transform((v) => (typeof v === "number" ? v : v.toNumber()))
                )
                .optional(),
            sortCode: z.nullable(z.string()).optional(),
            sourceModifiedDate: z.string().optional(),
            supplementalData: SupplementalData$.outboundSchema.optional(),
        })
        .transform((v) => {
            return {
                ...(v.accountName === undefined ? null : { accountName: v.accountName }),
                ...(v.accountNumber === undefined ? null : { accountNumber: v.accountNumber }),
                ...(v.accountType === undefined ? null : { accountType: v.accountType }),
                ...(v.availableBalance === undefined
                    ? null
                    : { availableBalance: v.availableBalance }),
                ...(v.balance === undefined ? null : { balance: v.balance }),
                ...(v.currency === undefined ? null : { currency: v.currency }),
                ...(v.iBan === undefined ? null : { iBan: v.iBan }),
                ...(v.id === undefined ? null : { id: v.id }),
                ...(v.institution === undefined ? null : { institution: v.institution }),
                ...(v.metadata === undefined ? null : { metadata: v.metadata }),
                ...(v.modifiedDate === undefined ? null : { modifiedDate: v.modifiedDate }),
                ...(v.nominalCode === undefined ? null : { nominalCode: v.nominalCode }),
                ...(v.overdraftLimit === undefined ? null : { overdraftLimit: v.overdraftLimit }),
                ...(v.sortCode === undefined ? null : { sortCode: v.sortCode }),
                ...(v.sourceModifiedDate === undefined
                    ? null
                    : { sourceModifiedDate: v.sourceModifiedDate }),
                ...(v.supplementalData === undefined
                    ? null
                    : { supplementalData: v.supplementalData }),
            };
        });
}
